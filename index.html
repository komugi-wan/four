<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Grid Memo Pro</title>
    <style>
        :root {
            --header-height: 100px;
            --cell-width: 15em;
            --base-font-size: 16px;
            --zoom-level: 1;
            --accent-color: #007AFF;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: sans-serif; background: #f4f4f4; }

        /* --- Header Section --- */
        header {
            height: var(--header-height);
            background: #fff;
            border-bottom: 1px solid #ccc;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
            z-index: 100;
        }
        .header-top { display: flex; justify-content: space-between; align-items: center; }
        .header-bottom { display: flex; gap: 10px; align-items: center; }
        
        button { padding: 6px 12px; border-radius: 6px; border: 1px solid #ccc; background: #eee; font-size: 14px; }
        .btn-add { background: var(--accent-color); color: white; border: none; }
        .btn-del { background: #ff3b30; color: white; border: none; }
        select { flex: 1; padding: 5px; font-size: 16px; border-radius: 6px; }
        input#sheet-name-input { border: 1px solid #ddd; padding: 4px; border-radius: 4px; width: 120px; }

        /* --- Grid Section --- */
        #viewport {
            height: calc(100% - var(--header-height));
            overflow: auto;
            position: relative;
            touch-action: none; /* JSで制御するため */
        }

        #grid-container {
            display: grid;
            grid-template-columns: 40px repeat(12, var(--cell-width));
            transform-origin: 0 0;
            will-change: transform;
            background: #ddd;
            gap: 1px;
        }

        .cell {
            background: #fff;
            min-height: 2em;
            max-height: 100em;
            padding: 8px;
            font-size: var(--base-font-size);
            word-break: break-all;
            display: flex;
            align-items: flex-start;
            overflow: hidden;
        }

        /* Labels (Sticky) */
        .label {
            background: #f8f8f8;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            position: sticky;
            z-index: 10;
        }
        .col-label { top: 0; height: 30px; border-bottom: 2px solid #ccc; }
        .row-label { left: 0; width: 40px; border-right: 2px solid #ccc; }
        .corner { top: 0; left: 0; z-index: 20; }

        /* --- Modal Editor --- */
        #editor-modal {
            position: fixed;
            bottom: -100%;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 1000;
            transition: bottom 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
        }
        #editor-modal.active { bottom: 0; }
        .modal-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
        }
        #editor-textarea {
            flex: 1;
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border: none;
            outline: none;
            resize: none;
        }
        .char-count { color: #666; font-size: 14px; }
    </style>
</head>
<body>

<header>
    <div class="header-top">
        <input type="text" id="sheet-name-input" placeholder="Sheet Name">
        <div>
            <button class="btn-add" onclick="addNewSheet()">＋追加</button>
            <button class="btn-del" onclick="deleteCurrentSheet()">削除</button>
        </div>
    </div>
    <div class="header-bottom">
        <select id="sheet-selector" onchange="switchSheet(this.value)"></select>
    </div>
</header>

<div id="viewport">
    <div id="grid-container">
        </div>
</div>

<div id="editor-modal">
    <div class="modal-header">
        <span class="char-count" id="char-count">0 文字</span>
        <div>
            <button onclick="closeEditor()">キャンセル</button>
            <button class="btn-add" onclick="saveCell()">完了</button>
        </div>
    </div>
    <textarea id="editor-textarea" placeholder="メモを入力..."></textarea>
</div>

<script>
    /** --- データベース関連 (IndexedDB) --- **/
    let db;
    const DB_NAME = "GridMemoDB";
    const STORE_SHEETS = "sheets";
    const STORE_DATA = "cellData";

    const initDB = () => {
        return new Promise((resolve) => {
            const request = indexedDB.open(DB_NAME, 1);
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                db.createObjectStore(STORE_SHEETS, { keyPath: "id", autoIncrement: true });
                db.createObjectStore(STORE_DATA, { keyPath: "key" }); // key = sheetId-row-col
            };
            request.onsuccess = (e) => {
                db = e.target.result;
                resolve();
            };
        });
    };

    /** --- グローバル状態 --- **/
    let currentSheetId = null;
    let editingCell = null; // {row, col}
    let zoom = 1;
    let startDist = 0;
    let startZoom = 1;

    /** --- UI制御 --- **/
    const grid = document.getElementById('grid-container');
    const viewport = document.getElementById('viewport');

    async function initApp() {
        await initDB();
        const sheets = await getAllSheets();
        if (sheets.length === 0) {
            await addNewSheet("シート1");
        } else {
            renderSheetList(sheets);
            await switchSheet(sheets[0].id);
        }
        setupTouchEvents();
    }

    async function addNewSheet(name = "新規シート") {
        const tx = db.transaction(STORE_SHEETS, "readwrite");
        const id = await new Promise(r => {
            const req = tx.objectStore(STORE_SHEETS).add({ name });
            req.onsuccess = () => r(req.result);
        });
        const sheets = await getAllSheets();
        renderSheetList(sheets);
        await switchSheet(id);
    }

    async function deleteCurrentSheet() {
        if (!confirm("このシートを削除しますか？")) return;
        const tx = db.transaction([STORE_SHEETS, STORE_DATA], "readwrite");
        tx.objectStore(STORE_SHEETS).delete(currentSheetId);
        // 本来は紐づくセルデータも消すべきだが、簡易化のため割愛
        const sheets = await getAllSheets();
        if (sheets.length > 0) await switchSheet(sheets[0].id);
        else await addNewSheet();
        renderSheetList(sheets);
    }

    async function switchSheet(id) {
        currentSheetId = parseInt(id);
        const sheets = await getAllSheets();
        const current = sheets.find(s => s.id === currentSheetId);
        document.getElementById('sheet-name-input').value = current.name;
        document.getElementById('sheet-selector').value = currentSheetId;
        renderGrid();
    }

    async function renderGrid() {
        grid.innerHTML = '';
        // Corner
        const corner = document.createElement('div');
        corner.className = 'cell label corner';
        grid.appendChild(corner);

        // Col Headers (A-L)
        for (let i = 0; i < 12; i++) {
            const div = document.createElement('div');
            div.className = 'cell label col-label';
            div.textContent = String.fromCharCode(65 + i);
            grid.appendChild(div);
        }

        // Rows
        for (let r = 1; r <= 50; r++) {
            const rowLabel = document.createElement('div');
            rowLabel.className = 'cell label row-label';
            rowLabel.textContent = r;
            grid.appendChild(rowLabel);

            for (let c = 0; c < 12; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${r}-${c}`;
                cell.onclick = () => openEditor(r, c);
                grid.appendChild(cell);
                loadCellValue(r, c);
            }
        }
    }

    /** --- セル編集・保存 --- **/
    async function openEditor(r, c) {
        editingCell = { r, c };
        const data = await getCellValue(r, c);
        const modal = document.getElementById('editor-modal');
        const textarea = document.getElementById('editor-textarea');
        textarea.value = data || "";
        updateCharCount();
        modal.classList.add('active');
        textarea.focus();
    }

    function closeEditor() {
        document.getElementById('editor-modal').classList.remove('active');
    }

    async function saveCell() {
        const text = document.getElementById('editor-textarea').value;
        const key = `${currentSheetId}-${editingCell.r}-${editingCell.c}`;
        const tx = db.transaction(STORE_DATA, "readwrite");
        tx.objectStore(STORE_DATA).put({ key, text });
        document.getElementById(`cell-${editingCell.r}-${editingCell.c}`).textContent = text;
        closeEditor();
    }

    async function loadCellValue(r, c) {
        const val = await getCellValue(r, c);
        if (val) document.getElementById(`cell-${r}-${c}`).textContent = val;
    }

    function getCellValue(r, c) {
        return new Promise(res => {
            const key = `${currentSheetId}-${r}-${c}`;
            const req = db.transaction(STORE_DATA).objectStore(STORE_DATA).get(key);
            req.onsuccess = () => res(req.result ? req.result.text : "");
        });
    }

    /** --- ズーム & スクロール制御 --- **/
    function setupTouchEvents() {
        viewport.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                startDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                startZoom = zoom;
            }
        });

        viewport.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                const factor = dist / startDist;
                zoom = Math.min(Math.max(startZoom * factor, 0.2), 3); // 0.2で約5列表示
                applyZoom();
            } else {
                // 通常スクロール
                viewport.scrollLeft -= e.movementX || 0;
                viewport.scrollTop -= e.movementY || 0;
            }
        }, { passive: false });
    }

    function applyZoom() {
        grid.style.transform = `scale(${zoom})`;
        // Sticky位置の補正はCSSのtransform-originにより概ね自動で行われるが、
        // 描画エリアのサイズを更新してスクロール可能範囲を維持する
        grid.style.width = `calc(100% * ${1/zoom})`; 
    }

    /** --- 補助関数 --- **/
    async function getAllSheets() {
        return new Promise(r => {
            const req = db.transaction(STORE_SHEETS).objectStore(STORE_SHEETS).getAll();
            req.onsuccess = () => r(req.result);
        });
    }

    function renderSheetList(sheets) {
        const sel = document.getElementById('sheet-selector');
        sel.innerHTML = sheets.map(s => `<option value="${s.id}">${s.name}</option>`).join('');
    }

    function updateCharCount() {
        const len = document.getElementById('editor-textarea').value.length;
        document.getElementById('char-count').textContent = `${len} 文字`;
    }

    document.getElementById('editor-textarea').oninput = updateCharCount;
    document.getElementById('sheet-name-input').onchange = async (e) => {
        const name = e.target.value;
        const tx = db.transaction(STORE_SHEETS, "readwrite");
        tx.objectStore(STORE_SHEETS).put({ id: currentSheetId, name });
        const sheets = await getAllSheets();
        renderSheetList(sheets);
        document.getElementById('sheet-selector').value = currentSheetId;
    };

    window.onload = initApp;
</script>
</body>
</html>
