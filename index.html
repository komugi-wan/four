<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Grid Memo</title>
<style>
/* * ==========================================
 * Theme & Reset
 * ==========================================
 */
:root {
    --theme-base: #fdf5f7;       /* 背景：極薄いピンク */
    --theme-surface: #ffffff;    /* セル背景：白 */
    --theme-primary: #bfafb5;    /* 枠線・アクセント：くすみピンク（濃） */
    --theme-secondary: #eadde2;  /* ヘッダー背景：くすみピンク（薄） */
    --theme-text: #5d4c51;       /* 文字色：温かみのあるダークグレー */
    --theme-highlight: #d68c9e;  /* 強調・ボタン：上品なピンク */
    
    --header-height: 50px;
    --cell-base-width: 160px;    /* 15文字程度が収まる幅 */
    --font-size: 16px;
    
    --shadow-soft: 0 2px 8px rgba(93, 76, 81, 0.08);
    --ease-out: cubic-bezier(0.25, 0.8, 0.25, 1);
}

* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
html, body {
    margin: 0; padding: 0; width: 100%; height: 100%;
    background-color: var(--theme-base);
    color: var(--theme-text);
    font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Yu Gothic", sans-serif;
    overflow: hidden; /* アプリ全体はスクロールさせない */
    overscroll-behavior: none;
}

/* * ==========================================
 * App Structure
 * ==========================================
 */
#app {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
}

/* Header Area */
header {
    height: var(--header-height);
    background-color: var(--theme-surface);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    box-shadow: 0 1px 0 var(--theme-primary);
    z-index: 100;
    flex-shrink: 0;
}

h1 {
    font-size: 18px;
    font-weight: 600;
    margin: 0;
    color: var(--theme-text);
    display: flex;
    align-items: center;
    gap: 8px;
}
.sheet-select {
    background: transparent;
    border: none;
    font-size: 16px;
    font-weight: bold;
    color: var(--theme-text);
    outline: none;
    max-width: 150px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.controls {
    display: flex;
    gap: 16px;
}

.icon-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 8px;
    color: var(--theme-highlight);
    display: flex;
    align-items: center;
    justify-content: center;
}
.icon-btn svg { width: 24px; height: 24px; fill: currentColor; }

/* * ==========================================
 * Grid Container & Zoom Logic
 * ==========================================
 */
#viewport {
    flex: 1;
    overflow: auto; /* ここがスクロールする */
    position: relative;
    background-color: var(--theme-base);
    overscroll-behavior: none;
}

/* Sizer: 
   transformで見た目が大きくなっても、DOMフロー上のサイズは変わらないため、
   JSで計算した「拡大後のピクセルサイズ」をこのdivに適用して
   強制的にスクロールバーを発生させる。
*/
#grid-sizer {
    width: 1px; 
    height: 1px;
    transform-origin: 0 0;
}

/* Scaler:
   実際に transform: scale() が適用される要素。
   grid-sizer の中に配置。
*/
#grid-scaler {
    transform-origin: 0 0;
    will-change: transform;
}

/* Grid Layout:
   Scalerの中に配置。実際のサイズ（scale=1の状態）を持つ。
*/
#grid-table {
    display: grid;
    /* 1列目は行番号用、残りはデータ用 */
    grid-template-columns: 40px repeat(12, var(--cell-base-width));
    /* 行数はJSで生成時に repeat(50, auto) のように扱う */
    background-color: var(--theme-primary); /* グリッド線代わり */
    gap: 1px;
    border-bottom: 1px solid var(--theme-primary);
    border-right: 1px solid var(--theme-primary);
}

/* Headers & Sticky */
.cell {
    background-color: var(--theme-surface);
    padding: 8px;
    font-size: var(--font-size);
    line-height: 1.5;
    min-height: 2.5em; /* 最低の高さ */
    max-height: calc(1.5em * 6); /* 文字量に応じて可変だが、最大100文字程度で見切れるように制限(約6行) */
    overflow: hidden;
    outline: none;
    position: relative;
    word-break: break-all;
    white-space: pre-wrap;
}

/* Sticky Configuration */
/* 行ヘッダー（左端） */
.cell.row-header {
    background-color: var(--theme-secondary);
    color: var(--theme-text);
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    position: sticky;
    left: 0;
    z-index: 10;
    user-select: none;
}

/* 列ヘッダー（上端） */
.cell.col-header {
    background-color: var(--theme-secondary);
    color: var(--theme-text);
    font-weight: bold;
    text-align: center;
    position: sticky;
    top: 0;
    z-index: 10;
    user-select: none;
    height: 40px; /* ヘッダー高さ固定 */
    display: flex;
    align-items: center;
    justify-content: center;
}

/* 左上角（固定） */
.cell.corner-header {
    position: sticky;
    top: 0;
    left: 0;
    z-index: 20; /* 最前面 */
    background-color: var(--theme-secondary);
}

/* 通常セル編集時のスタイル */
.cell:focus {
    background-color: #fff0f5;
    box-shadow: inset 0 0 0 2px var(--theme-highlight);
}

/* 長文編集ボタン (フォーカス時にJSで制御、または常に薄く表示) */
.expand-btn {
    position: absolute;
    bottom: 2px;
    right: 2px;
    width: 20px;
    height: 20px;
    background: var(--theme-highlight);
    border-radius: 50%;
    color: white;
    font-size: 12px;
    border: none;
    display: none; /* フォーカス時に表示 */
    align-items: center;
    justify-content: center;
    z-index: 5;
    opacity: 0.8;
}
.cell:focus .expand-btn {
    display: flex;
}

/* * ==========================================
 * Full Screen Editor (Slide Up)
 * ==========================================
 */
#editor-overlay {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: #fff;
    z-index: 2000;
    transform: translateY(100%);
    transition: transform 0.3s var(--ease-out);
    display: flex;
    flex-direction: column;
}
#editor-overlay.active {
    transform: translateY(0);
}

.editor-header {
    height: 56px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    border-bottom: 1px solid var(--theme-secondary);
    background: var(--theme-base);
}
.editor-title {
    font-weight: bold;
    color: var(--theme-text);
}
.save-btn {
    color: var(--theme-highlight);
    font-weight: bold;
    border: none;
    background: none;
    font-size: 16px;
    padding: 8px;
}

.editor-body {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
}
#full-text-area {
    width: 100%;
    height: 100%;
    border: none;
    resize: none;
    font-size: 18px;
    line-height: 1.6;
    outline: none;
    color: #333;
    font-family: inherit;
}
.char-count {
    padding: 10px 16px;
    text-align: right;
    font-size: 12px;
    color: #999;
    background: #fff;
}

/* * ==========================================
 * Sheet Manager Modal
 * ==========================================
 */
.modal-overlay {
    position: fixed;
    top:0; left:0; width:100%; height:100%;
    background: rgba(0,0,0,0.4);
    z-index: 3000;
    display: none;
    align-items: center;
    justify-content: center;
}
.modal-overlay.open { display: flex; }
.modal-card {
    background: #fff;
    width: 80%;
    max-width: 320px;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.1);
}
.modal-card h3 { margin-top: 0; color: var(--theme-text); }
.sheet-list {
    list-style: none;
    padding: 0;
    max-height: 200px;
    overflow-y: auto;
    margin: 15px 0;
    border: 1px solid #eee;
}
.sheet-item {
    padding: 10px;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.sheet-item.active { background: #fff0f5; font-weight: bold; }
.modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}
.btn {
    padding: 8px 16px;
    border-radius: 6px;
    border: none;
    font-size: 14px;
}
.btn-primary { background: var(--theme-highlight); color: #fff; }
.btn-text { background: transparent; color: #888; }

</style>
</head>
<body>

<div id="app">
    <header>
        <h1>
            <span id="current-sheet-name" class="sheet-select" onclick="SheetManager.open()">Sheet 1</span>
            <svg width="12" height="12" viewBox="0 0 24 24" fill="#999"><path d="M7 10l5 5 5-5z"/></svg>
        </h1>
        <div class="controls">
            <button class="icon-btn" onclick="SheetManager.open()" aria-label="Sheets">
                <svg viewBox="0 0 24 24"><path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/></svg>
            </button>
        </div>
    </header>

    <div id="viewport">
        <div id="grid-sizer">
            <div id="grid-scaler">
                <div id="grid-table">
                    </div>
            </div>
        </div>
    </div>
</div>

<div id="editor-overlay">
    <div class="editor-header">
        <span class="editor-title" id="editor-title-ref">A1</span>
        <button class="save-btn" onclick="Editor.close()">完了</button>
    </div>
    <div class="editor-body">
        <textarea id="full-text-area" placeholder="ここに入力..."></textarea>
    </div>
    <div class="char-count" id="char-count">0文字</div>
</div>

<div id="sheet-modal" class="modal-overlay">
    <div class="modal-card">
        <h3>シート管理</h3>
        <ul id="sheet-list-ui" class="sheet-list"></ul>
        <div class="modal-actions">
            <button class="btn btn-text" onclick="SheetManager.addSheet()">＋ 新規作成</button>
            <button class="btn btn-primary" onclick="SheetManager.close()">閉じる</button>
        </div>
    </div>
</div>

<script>
/* * ==========================================
 * Core Logic (Vanilla JS)
 * ==========================================
 */

const CONFIG = {
    rows: 50,
    cols: 12,
    colLabels: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    baseWidth: 160, // px per col
    headerWidth: 40, // px
    rowHeight: 24,   // base px
    dbName: 'GridMemoDB',
    dbVersion: 1
};

// State
let state = {
    currentSheetId: null,
    scale: 1.0,
    sheets: [], // metadata only
    data: {} // current sheet cells: { "r_c": "text" }
};

/* * ==========================================
 * IndexedDB Wrapper
 * ==========================================
 */
const DB = {
    db: null,
    async init() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(CONFIG.dbName, CONFIG.dbVersion);
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('sheets')) {
                    db.createObjectStore('sheets', { keyPath: 'id' });
                }
            };
            req.onsuccess = (e) => {
                this.db = e.target.result;
                resolve();
            };
            req.onerror = (e) => reject(e);
        });
    },
    async getAllSheets() {
        return new Promise(resolve => {
            const tx = this.db.transaction('sheets', 'readonly');
            const store = tx.objectStore('sheets');
            const req = store.getAll();
            req.onsuccess = () => resolve(req.result);
        });
    },
    async saveSheet(sheet) {
        return new Promise(resolve => {
            const tx = this.db.transaction('sheets', 'readwrite');
            const store = tx.objectStore('sheets');
            store.put(sheet);
            tx.oncomplete = () => resolve();
        });
    },
    async deleteSheet(id) {
        return new Promise(resolve => {
            const tx = this.db.transaction('sheets', 'readwrite');
            const store = tx.objectStore('sheets');
            store.delete(id);
            tx.oncomplete = () => resolve();
        });
    }
};

/* * ==========================================
 * UI Renderer
 * ==========================================
 */
const UI = {
    gridTable: document.getElementById('grid-table'),
    gridSizer: document.getElementById('grid-sizer'),
    gridScaler: document.getElementById('grid-scaler'),
    viewport: document.getElementById('viewport'),
    sheetName: document.getElementById('current-sheet-name'),

    init() {
        this.renderGridStructure();
        this.initZoom();
    },

    renderGridStructure() {
        this.gridTable.innerHTML = '';
        
        // Corner (0,0)
        const corner = document.createElement('div');
        corner.className = 'cell corner-header';
        this.gridTable.appendChild(corner);

        // Column Headers (A-L)
        for (let c = 0; c < CONFIG.cols; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell col-header';
            cell.textContent = CONFIG.colLabels[c] || c;
            this.gridTable.appendChild(cell);
        }

        // Rows
        for (let r = 0; r < CONFIG.rows; r++) {
            // Row Header (1-50)
            const rowHead = document.createElement('div');
            rowHead.className = 'cell row-header';
            rowHead.textContent = r + 1;
            this.gridTable.appendChild(rowHead);

            // Cells
            for (let c = 0; c < CONFIG.cols; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell data-cell';
                cell.dataset.r = r;
                cell.dataset.c = c;
                cell.contentEditable = true;
                cell.spellcheck = false;
                
                // Expand Button
                const btn = document.createElement('button');
                btn.className = 'expand-btn';
                btn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>';
                btn.contentEditable = false; // Prevent cursor entering button
                btn.addEventListener('touchstart', (e) => {
                    e.stopPropagation(); // prevent focus jump
                    e.preventDefault();
                    Editor.open(r, c);
                });
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    Editor.open(r, c); // Fallback for click
                });

                cell.appendChild(btn);

                // Events
                cell.addEventListener('input', (e) => {
                    App.updateCell(r, c, e.target.firstChild.textContent || e.target.innerText); // Robust text retrieval
                });
                
                this.gridTable.appendChild(cell);
            }
        }
    },

    loadDataToGrid(data) {
        // Clear all cells first (keep buttons)
        const cells = document.querySelectorAll('.data-cell');
        cells.forEach(cell => {
             // Keep the button, clear text
             const btn = cell.querySelector('.expand-btn');
             cell.innerText = ""; 
             if(btn) cell.appendChild(btn);
             
             const key = `${cell.dataset.r}_${cell.dataset.c}`;
             if (data[key]) {
                 // Insert text before button
                 cell.prepend(document.createTextNode(data[key]));
             }
        });
    },

    /* Zoom Logic */
    initZoom() {
        let startDist = 0;
        let startScale = 1;
        const minScale = 0.3; // 5 columns visible logic roughly
        const maxScale = 2.0;

        // Base Grid Size (Unscaled)
        const baseGridWidth = CONFIG.headerWidth + (CONFIG.cols * CONFIG.baseWidth);
        const baseGridHeight = CONFIG.headerHeight + (CONFIG.rows * 40); // approx

        // Set initial sizer size
        const updateSizer = (s) => {
            // Sizer size = Unscaled Size * Scale Factor
            // This forces the viewport to show scrollbars appropriate for the zoomed content
            // The Scaler is inside the Sizer.
            
            // Calculate actual rendered size of the grid
            const rect = this.gridTable.getBoundingClientRect();
            // Note: getBoundingClientRect is affected by transform.
            
            // Robust approach:
            // Sizer acts as the "Virtual Canvas" size.
            // Scaler is the layer being transformed.
            
            // Grid's natural width
            const naturalWidth = this.gridTable.offsetWidth;
            const naturalHeight = this.gridTable.offsetHeight;

            this.gridSizer.style.width = `${naturalWidth * s}px`;
            this.gridSizer.style.height = `${naturalHeight * s}px`;
            
            this.gridScaler.style.transform = `scale(${s})`;
        };

        this.viewport.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault(); // Prevent native zoom
                startDist = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
                startScale = state.scale;
            }
        }, { passive: false });

        this.viewport.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                const dist = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
                if (startDist > 0) {
                    const diff = dist / startDist;
                    let newScale = startScale * diff;
                    newScale = Math.min(Math.max(newScale, minScale), maxScale);
                    
                    state.scale = newScale;
                    updateSizer(newScale);
                }
            }
        }, { passive: false });

        // Initial setup
        // Wait for render
        setTimeout(() => updateSizer(1.0), 100);
    }
};

/* * ==========================================
 * Editor Logic
 * ==========================================
 */
const Editor = {
    overlay: document.getElementById('editor-overlay'),
    textarea: document.getElementById('full-text-area'),
    title: document.getElementById('editor-title-ref'),
    count: document.getElementById('char-count'),
    currentR: null,
    currentC: null,

    open(r, c) {
        this.currentR = r;
        this.currentC = c;
        const key = `${r}_${c}`;
        const val = state.data[key] || "";
        
        // Column label
        const label = CONFIG.colLabels[c] + (parseInt(r) + 1);
        this.title.textContent = label;
        this.textarea.value = val;
        this.updateCount();
        
        this.overlay.classList.add('active');
        this.textarea.focus();
    },

    close() {
        const val = this.textarea.value;
        App.updateCell(this.currentR, this.currentC, val);
        
        // Update UI grid immediately
        const cell = document.querySelector(`.data-cell[data-r='${this.currentR}'][data-c='${this.currentC}']`);
        if(cell) {
             const btn = cell.querySelector('.expand-btn');
             cell.innerText = ""; 
             if(btn) cell.appendChild(btn);
             cell.prepend(document.createTextNode(val));
        }

        this.overlay.classList.remove('active');
    },

    updateCount() {
        this.count.textContent = `${this.textarea.value.length}文字`;
    }
};

document.getElementById('full-text-area').addEventListener('input', () => Editor.updateCount());

/* * ==========================================
 * Sheet Manager
 * ==========================================
 */
const SheetManager = {
    modal: document.getElementById('sheet-modal'),
    list: document.getElementById('sheet-list-ui'),

    async open() {
        this.renderList();
        this.modal.classList.add('open');
    },

    close() {
        this.modal.classList.remove('open');
    },

    async renderList() {
        this.list.innerHTML = '';
        state.sheets.forEach(sheet => {
            const li = document.createElement('li');
            li.className = `sheet-item ${sheet.id === state.currentSheetId ? 'active' : ''}`;
            
            const span = document.createElement('span');
            span.textContent = sheet.name;
            span.onclick = () => App.switchSheet(sheet.id);
            
            const delBtn = document.createElement('button');
            delBtn.innerHTML = '✕';
            delBtn.className = 'btn btn-text';
            delBtn.style.color = '#999';
            delBtn.onclick = (e) => {
                e.stopPropagation();
                if(confirm('このシートを削除しますか？')) App.deleteSheet(sheet.id);
            };

            li.appendChild(span);
            // Don't allow deleting the last sheet
            if (state.sheets.length > 1) {
                li.appendChild(delBtn);
            }
            this.list.appendChild(li);
        });
    },

    addSheet() {
        App.createSheet();
        this.close();
    }
};

/* * ==========================================
 * Main App Controller
 * ==========================================
 */
const App = {
    async init() {
        await DB.init();
        UI.init();
        
        const sheets = await DB.getAllSheets();
        if (sheets.length === 0) {
            await this.createSheet("メインシート");
        } else {
            state.sheets = sheets;
            // Load last used or first
            this.switchSheet(sheets[0].id);
        }
    },

    async createSheet(nameBase) {
        const id = Date.now();
        const name = nameBase || `Sheet ${state.sheets.length + 1}`;
        const newSheet = { id, name, cells: {} };
        
        await DB.saveSheet(newSheet);
        state.sheets.push(newSheet);
        this.switchSheet(id);
    },

    async switchSheet(id) {
        const sheet = state.sheets.find(s => s.id === id);
        if (!sheet) return;

        state.currentSheetId = id;
        state.data = sheet.cells || {};
        UI.sheetName.textContent = sheet.name;
        UI.loadDataToGrid(state.data);
        SheetManager.close();
        
        // Scroll reset
        document.getElementById('viewport').scrollTop = 0;
        document.getElementById('viewport').scrollLeft = 0;
    },

    async deleteSheet(id) {
        await DB.deleteSheet(id);
        state.sheets = state.sheets.filter(s => s.id !== id);
        if (state.sheets.length === 0) await this.createSheet();
        else this.switchSheet(state.sheets[0].id);
        SheetManager.renderList();
    },

    // Debounced save
    saveTimeout: null,
    updateCell(r, c, text) {
        const key = `${r}_${c}`;
        state.data[key] = text;
        
        if (this.saveTimeout) clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(() => {
            this.persistCurrentSheet();
        }, 500);
    },

    async persistCurrentSheet() {
        const sheet = state.sheets.find(s => s.id === state.currentSheetId);
        if (sheet) {
            sheet.cells = state.data;
            await DB.saveSheet(sheet);
        }
    }
};

// Start
window.addEventListener('DOMContentLoaded', () => {
    App.init();
});

</script>
</body>
</html>
